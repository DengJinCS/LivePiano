8.16日

目前已经实现了一首单音曲子的following，但是这是一首非常简单的曲子，也就是说不会有一些特殊的情况来挑战我们目前的算法。

目前针对异常我做了如下的一些处理

- 针对两个检测到连续的onset，我设定后一个onset不能和当前已经匹配到的onset相隔超过0.25秒，我在算法中加入了处理，会抛弃0.25秒以内的第二个onset。这个设置一定程度上会把误检的onset消除掉。
- 进行look-ahead note matching的时候， j的搜索空间应该低于j1，不能取到j1，文献上写的是可以取到j1![](/Users/wanglei/Pictures/score_following1.jpg)

如果取到了j1,**可能会影响被跳过的音符检测**。**所以这里在算法中绝对不能取到j1。**

- **如果有一个onset没有检测到，现在会影响后续的onset检测**。解决办法通过放宽onset检测bound，或者增加onset检测算法的准确度，这是一个onset驱动的算法。



8.23日

这几天尝试了对一首MAPS中复音的曲子进行测试，碰到了如下问题：

- onset检测漏检了一个onset，那么该如何解决呢，这个算法如果漏检了一个就会马上影响到后续的onset检测。 **在真正的系统中应该是要重复检查是不是有onset**
- 设置0.1s的检测窗口，25ms的容忍窗口，我们发现onset检测召回率为98.815%，那么在真实的钢琴演奏情况中，这个onset检测率有这么高吗？

后来我版onset_bound设置成0.4， 把start_point_2改成了+1之后，我发现漏检的onset也能够全部都检测到了，onset检测率上升到了100%

